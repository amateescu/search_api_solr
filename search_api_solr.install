<?php

use Drupal\Core\Config\StorageInterface;
use Drupal\Core\Config\FileStorage;
use Drupal\Core\Config\InstallStorage;
use Drupal\search_api_solr\SolrBackendInterface;
use Drupal\search_api\Entity\Server;
use Drupal\Core\Url;

/**
 * Implements hook_requirements().
 */
function search_api_solr_requirements($phase) {
  $requirements = [];

  if ($phase == 'install') {
    if (!class_exists('\Solarium\Core\Client\Request')) {
      $requirements['search_api_solr_library'] = [
        'description' => t('Solr search requires the solarium/solarium library.'),
        'severity' => REQUIREMENT_ERROR,
      ];
    }
  }
  elseif ($phase == 'runtime') {
    $servers = search_api_solr_get_active_servers();
    $count = 0;
    $unavailable = 0;
    $multiple_indexes = 0;
    $last = NULL;
    foreach ($servers as $server_id => $server) {
      if (!$server->getBackend()->isAvailable()) {
        ++$unavailable;
        $last = $server;
      }
      $indexes = $server->getIndexes();
      if (count($indexes) > 1) {
        $active = 0;
        foreach ($indexes as $index) {
          if ($index->status()) {
            ++$active;
          }
        }
        if ($active > 1) {
          ++$multiple_indexes;
        }
      }
      ++$count;
    }
    if (!$count) {
      return [];
    }
    $requirements['search_api_solr'] = [
      'title' => \Drupal::translation()->translate('Solr servers'),
      'value' => \Drupal::translation()->formatPlural($count, '1 server', '@count servers'),
    ];
    if ($unavailable) {
      if ($unavailable == 1) {
        $requirements['search_api_solr']['description'] = \Drupal::translation()->translate('The Solr server of <a href=":url">%name</a> could not be reached.',
          [':url' => Url::fromRoute('entity.search_api_server.canonical', ['search_api_server' => $last->id()])->toString(), '%name' => $last->label()]);
      }
      else {
        $requirements['search_api_solr']['description'] = \Drupal::translation()->translate('@count Solr servers could not be reached.', ['@count' => $unavailable]);
      }
      $requirements['search_api_solr']['severity'] = REQUIREMENT_ERROR;
    }
    else {
      $requirements['search_api_solr']['description'] = \Drupal::translation()->formatPlural($count, 'The Solr server could be reached.', 'All @count Solr servers could be reached.');
      $requirements['search_api_solr']['severity'] = REQUIREMENT_OK;
    }

    $requirements['search_api_solr_multiple_indexes'] = [
      'title' => \Drupal::translation()->translate('Solr server indexes'),
      'value' => \Drupal::translation()->formatPlural($count, '1 server', '@count servers'),
    ];
    if ($multiple_indexes) {
      $requirements['search_api_solr_multiple_indexes']['description'] = \Drupal::translation()->formatPlural($multiple_indexes, 'One Solr server contains more than one enabled index.', '@count Solr servers contain more than one enabled index.');
      $requirements['search_api_solr_multiple_indexes']['severity'] = REQUIREMENT_ERROR;
    }
    else {
      $requirements['search_api_solr_multiple_indexes']['description'] = \Drupal::translation()->formatPlural($count, 'The Solr server does not contain more than one enabled index.', 'All @count Solr servers do not contain more than one enabled index.');
      $requirements['search_api_solr_multiple_indexes']['severity'] = REQUIREMENT_OK;
    }

    $storage = \Drupal::entityTypeManager()->getStorage('search_api_server');
    /** @var \Drupal\search_api\ServerInterface[] $servers */
    if ($servers = $storage->loadByProperties(['backend' => 'search_api_solr_multilingual'])) {
      foreach ($servers as $server) {
        $key = 'search_api_solr_multilingual_' . $server->id();
        $requirements[$key] = [
          'title' => t('Multilingual Solr Server'),
          'value' => t('Schema complete'),
          'severity' => REQUIREMENT_OK,
          'description' => t('Schema on server <a href=":url">@server</a> contains all required language-specific fields.', [
            ':url' => $server->toUrl('canonical')->toString(),
            '@server' => $server->label(),
          ]),
        ];

        /** @var \Drupal\search_api_solr\SolrMultilingualBackendInterface $backend */
        $backend = $server->getBackend();
        if ($backend->isAvailable()) {
          $stats = $backend->getSchemaLanguageStatistics();
          if ($missing_languages = array_filter($stats, function ($state) {
            return !$state;
          })) {
            $requirements[$key]['value'] = t('Schema incomplete');
            $requirements[$key]['severity'] = $backend->hasLanguageUndefinedFallback() ? REQUIREMENT_WARNING : REQUIREMENT_ERROR;
            $requirements[$key]['description'] = t(
              'There are some language-specific field types missing in schema of Solr server <a href=":url">@server</a>: @languages.', [
                ':url' => $server->toUrl('canonical')->toString(),
                '@server' => $server->label(),
                '@languages' => implode(', ', array_keys($missing_languages)),
              ]);
          }
        }
        else {
          $requirements[$key]['value'] = t('Not reachable');
          $requirements[$key]['severity'] = REQUIREMENT_ERROR;
          $requirements[$key]['description'] = t(
            'Solr server <a href=":url">@server</a> is not reachable.', [
              ':url' => $server->toUrl('canonical')->toString(),
              '@server' => $server->label(),
            ]);
        }
      }
    }
  }

  return $requirements;
}

/**
 * Gets all active Solr servers.
 *
 * @return \Drupal\search_api\Entity\Server[]
 *   All active Solr servers keyed by ids.
 */
function search_api_solr_get_active_servers() {
  $config_factory = \Drupal::configFactory();
  $servers = [];
  foreach ($config_factory->listAll('search_api.server.') as $server_config_name) {
    $server_id = $config_factory->get($server_config_name)->get('id');
    $server = Server::load($server_id);
    // Covers search_api_solr_multilingual, too.
    if (($server->getBackend() instanceof SolrBackendInterface) && $server->status()) {
      $servers[$server_id] = $server;
    }
  }
  return $servers;
}

/**
 * Implements hook_uninstall().
 */
function search_api_solr_uninstall() {
  \Drupal::state()->delete('search_api_solr.last_optimize');
  \Drupal::state()->delete('search_api_solr.endpoint.data');
}

/**
 * Gets all backend configs for active Solr servers.
 *
 * @return array
 *   All backend configs for active Solr servers keyed by server name.
 */
function search_api_solr_update_helper_get_backend_configs($prefix = 'search_api_solr') {
  $config_factory = \Drupal::configFactory();
  $backend_configs = [];
  foreach ($config_factory->listAll('search_api.server.') as $server_name) {
    $server = $config_factory->get($server_name);
    // Covers search_api_solr_multilingual, too.
    if (strpos($server->get('backend'), $prefix) === 0) {
      $backend_configs[$server_name] = $server->get('backend_config');
    }
  }
  return $backend_configs;
}

/**
 * Saves a modified backend config for a given Solr server.
 *
 * @param string $server_name
 * @param array $backend_config
 * @param bool $trusted_data
 */
function search_api_solr_update_helper_save_backend_config($server_name, array $backend_config, $trusted_data = TRUE) {
  \Drupal::configFactory()->getEditable($server_name)
    ->set('backend_config', $backend_config)
    ->save($trusted_data);
}

/**
 * Gets all solr field type configs.
 *
 * @return array
 *   All solr field type configs.
 */
function search_api_solr_update_helper_get_field_type_configs() {
  $config_factory = \Drupal::configFactory();
  $field_type_configs = [];
  foreach ($config_factory->listAll('search_api_solr.solr_field_type.') as $field_type_name) {
    $field_type_configs[$field_type_name] = $config_factory->get($field_type_name)->getRawData();
  }
  return $field_type_configs;
}

/**
 * Saves a modified solr field type config.
 *
 * @param string $field_type_name
 * @param array $field_type_config
 * @param bool $trusted_data
 */
function search_api_solr_update_helper_save_field_type_config($field_type_name, array $field_type_config, $trusted_data = TRUE) {
  \Drupal::configFactory()->getEditable($field_type_name)
    ->setData($field_type_config)
    ->save($trusted_data);
}

/**
 * Helper function to install all new optional configs.
 */
function search_api_solr_update_helper_install_new_optional_configs() {
  $optional_install_path = \Drupal::moduleHandler()->getModule('search_api_solr')->getPath() . '/' . InstallStorage::CONFIG_OPTIONAL_DIRECTORY;
  if (is_dir($optional_install_path)) {
    // Install any optional config the module provides.
    $storage = new FileStorage($optional_install_path, StorageInterface::DEFAULT_COLLECTION);
    /** @var \Drupal\Core\Config\ConfigInstallerInterface $config_installer */
    $config_installer = \Drupal::service('config.installer');
    $config_installer->installOptionalConfig($storage);
  }
}

/**
 * Helper function to install all new configs.
 */
function search_api_solr_update_helper_install_new_configs() {
  $settings = \Drupal::config('search_api_solr.settings')->getRawData();
  $standard_highlighter = \Drupal::config('search_api_solr.standard_highlighter')->getRawData();

  /** @var \Drupal\Core\Config\ConfigInstallerInterface $config_installer */
  $config_installer = \Drupal::service('config.installer');
  $config_installer->installDefaultConfig('module', 'search_api_solr');

  $settings += \Drupal::config('search_api_solr.settings')->getRawData();
  $standard_highlighter += \Drupal::config('search_api_solr.standard_highlighter')->getRawData();

  \Drupal::configFactory()->getEditable('search_api_solr.settings')->setData($settings)->save();
  \Drupal::configFactory()->getEditable('search_api_solr.standard_highlighter')->setData($standard_highlighter)->save();
}

/**
 * Split Solr paths stored in configurations into server and core parts.
 */
function search_api_solr_update_8001() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $parts = explode('/', $backend_config['path']);
    if (count($parts) > 2) {
      $backend_config['core'] = array_pop($parts);
      $backend_config['path'] = implode('/', $parts);
      search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
    }
  }
}

/**
 * Convert http_user and http_pass to username and password config for Solarium.
 */
function search_api_solr_update_8002() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['username'] = $backend_config['http_user'];
    $backend_config['password'] = $backend_config['http_pass'];
    unset($backend_config['http_user'], $backend_config['http_pass']);
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Add default timeout settings to existing configs.
 */
function search_api_solr_update_8003() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['timeout'] = 5;
    $backend_config['index_timeout'] = 5;
    $backend_config['optimize_timeout'] = 10;
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Migrate existing backend configurations to the basic auth connector plugin.
 */
function search_api_solr_update_8004() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['connector'] = 'basic_auth';
    $backend_config['connector_config'] = [];
    foreach (['scheme', 'host', 'port', 'path', 'core', 'timeout', 'index_timeout', 'optimize_timeout', 'solr_version', 'http_method', 'username', 'password'] as $key) {
      $backend_config['connector_config'][$key] = $backend_config[$key];
      unset($backend_config[$key]);
    }
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Add commit_within settings to existing connector configs.
 */
function search_api_solr_update_8005() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['connector_config']['commit_within'] = 1000;
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Add autocomplete settings to existing configs.
 */
function search_api_solr_update_8006() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['suggest_suffix'] = TRUE;
    $backend_config['suggest_corrections'] = TRUE;
    $backend_config['suggest_words'] = FALSE;
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Remove old autocomplete settings in existing configs.
 */
function search_api_solr_update_8007() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    unset($backend_config['autocorrect_spell']);
    unset($backend_config['autocorrect_suggest_words']);
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Remove obsolete settings in existing configs.
 */
function search_api_solr_update_8008() {
  $config_factory = \Drupal::configFactory();
  foreach ($config_factory->listAll('search_api_solr.settings.') as $setting) {
    $config = $config_factory->getEditable($setting);
    $data = $config->getRawData();
    unset($data['autocomplete_max_occurrences']);
    unset($data['http_get_max_length']);
    $config->setData($data);
    $config->save(TRUE);
  }
}

/**
 * Remove Search API Multilingual Solr Search left-overs.
 */
function search_api_solr_update_8200() {
  $database = Drupal::database();

  $database->delete('key_value')
    ->condition('collection', 'system.schema')
    ->condition('name', 'search_api_solr_multilingual')
    ->execute();
}

/**
 * Fix suggester field type.
 */
function search_api_solr_update_8201() {
  foreach (search_api_solr_update_helper_get_field_type_configs() as $field_type_name => $field_type_config) {
    if (!empty($field_type_config['solr_configs']) && !empty($field_type_config['solr_configs']['searchComponents'])) {
      foreach ($field_type_config['solr_configs']['searchComponents'] as &$component) {
        if ($component['name'] == 'suggest') {
          foreach ($component['lst'] as &$lst) {
            foreach ($lst['str'] as &$str) {
              foreach ($lst['str'] as &$entry) {
                if ($entry['name'] == 'field') {
                  $entry['VALUE'] = 'twm_suggest';
                  search_api_solr_update_helper_save_field_type_config($field_type_name, $field_type_config);
                  break;
                }
              }
            }
          }
        }
      }
    };
  }
}

/**
 * Enable support for targeted domains for all backends and add custom codes.
 */
function search_api_solr_update_8202() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    if (!isset($backend_config['domain'])) {
      if (isset($backend_config['sasm_domain'])) {
        $backend_config['domain'] = $backend_config['sasm_domain'];
        unset($backend_config['sasm_domain']);
      }
      else {
        $backend_config['domain'] = 'generic';
      }
    }
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }

  foreach (search_api_solr_update_helper_get_field_type_configs() as $field_type_name => $field_type_config) {
    if (!isset($field_type_config['custom_code'])) {
      $field_type_config['custom_code'] = '';
    }
    search_api_solr_update_helper_save_field_type_config($field_type_name, $field_type_config);
  }
}

/**
 * Install new essential Solr field types.
 */
function search_api_solr_update_8203() {
  search_api_solr_update_helper_install_new_configs();
}
