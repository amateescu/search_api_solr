<?php

use Drupal\Component\Serialization\Yaml;
use Drupal\Core\Config\StorageInterface;
use Drupal\Core\Config\FileStorage;
use Drupal\Core\Config\InstallStorage;
use Drupal\Core\Url;
use Drupal\search_api_solr\Entity\SolrFieldType;

/**
 * Implements hook_requirements().
 */
function search_api_solr_requirements($phase) {
  $requirements = [];

  if ($phase == 'install') {
    if (!class_exists('\Solarium\Core\Client\Request')) {
      $requirements['search_api_solr_library'] = [
        'description' => t('Solr search requires the solarium/solarium library.'),
        'severity' => REQUIREMENT_ERROR,
      ];
    }
  }
  elseif ($phase == 'runtime') {
    $servers = search_api_solr_get_servers();
    $count = 0;
    $unavailable = 0;
    $multiple_indexes = 0;
    $last = NULL;
    foreach ($servers as $server_id => $server) {
      if (!$server->getBackend()->isAvailable()) {
        ++$unavailable;
        $last = $server;
      }
      $indexes = $server->getIndexes();
      if (count($indexes) > 1) {
        $active = 0;
        foreach ($indexes as $index) {
          if ($index->status()) {
            ++$active;
          }
        }
        if ($active > 1) {
          ++$multiple_indexes;
        }
      }
      ++$count;
    }
    if (!$count) {
      return [];
    }
    $requirements['search_api_solr'] = [
      'title' => \Drupal::translation()->translate('Solr servers'),
      'value' => \Drupal::translation()->formatPlural($count, '1 server', '@count servers'),
    ];
    if ($unavailable) {
      if ($unavailable == 1) {
        $requirements['search_api_solr']['description'] = \Drupal::translation()->translate('The Solr server of <a href=":url">%name</a> could not be reached.',
          [':url' => Url::fromRoute('entity.search_api_server.canonical', ['search_api_server' => $last->id()])->toString(), '%name' => $last->label()]);
      }
      else {
        $requirements['search_api_solr']['description'] = \Drupal::translation()->translate('@count Solr servers could not be reached.', ['@count' => $unavailable]);
      }
      $requirements['search_api_solr']['severity'] = REQUIREMENT_ERROR;
    }
    else {
      $requirements['search_api_solr']['description'] = \Drupal::translation()->formatPlural($count, 'The Solr server could be reached.', 'All @count Solr servers could be reached.');
      $requirements['search_api_solr']['severity'] = REQUIREMENT_OK;
    }

    $requirements['search_api_solr_multiple_indexes'] = [
      'title' => \Drupal::translation()->translate('Solr servers with multiple indexes'),
      'value' => \Drupal::translation()->formatPlural($count, '1 server', '@count servers'),
    ];
    if ($multiple_indexes) {
      // @todo Warn if autocomplete uses an implementation that is not suitable
      // for multiple indexes per core. But we need the possibility to turn that
      // off if the user acknowledged it because he might really want to have
      // it like this as a feature.
    }

    foreach ($servers as $server) {
      $backend = $server->getBackend();
      $requirements['search_api_solr'][$server->id()] = [
        'title' => t('Solr Server %server_id', ['%server_id' => $server->id()]),
        'value' => t('Schema complete'),
        'severity' => REQUIREMENT_OK,
        'description' => t('Schema on server <a href=":url">@server</a> contains all required language-specific fields.', [
          ':url' => $server->toUrl('canonical')->toString(),
          '@server' => $server->label(),
        ]),
      ];

      if ($backend->isAvailable()) {
        $stats = $backend->getSchemaLanguageStatistics();
        if ($missing_languages = array_filter($stats, function ($state) {
          return !$state;
        })) {
          $requirements['search_api_solr'][$server->id()]['value'] = t('Schema incomplete');
          $requirements['search_api_solr'][$server->id()]['severity'] = REQUIREMENT_WARNING;
          $requirements['search_api_solr'][$server->id()]['description'] = t(
            'There are some language-specific field types missing in schema of Solr server <a href=":url">@server</a>: @languages.', [
            ':url' => $server->toUrl('canonical')->toString(),
            '@server' => $server->label(),
            '@languages' => implode(', ', array_keys($missing_languages)),
          ]);
        }
      }
      else {
        $requirements['search_api_solr'][$server->id()]['value'] = t('Not reachable');
        $requirements['search_api_solr'][$server->id()]['severity'] = REQUIREMENT_ERROR;
        $requirements['search_api_solr'][$server->id()]['description'] = t(
          'Solr server <a href=":url">@server</a> is not reachable.', [
          ':url' => $server->toUrl('canonical')->toString(),
          '@server' => $server->label(),
        ]);
      }
    }
  }

  return $requirements;
}

/**
 * Implements hook_uninstall().
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\search_api\SearchApiException
 */
function search_api_solr_uninstall() {
  \Drupal::state()->delete('search_api_solr.last_optimize');
  \Drupal::state()->delete('search_api_solr.endpoint.data');
  foreach (search_api_solr_get_servers() as $server) {
    foreach ($server->getIndexes() as $index) {
      \Drupal::state()->delete('search_api_solr.' . $index->id() . '.last_update');
    }
    \Drupal::state()->delete('search_api_solr.' . $server->id() . '.schema_parts');
  }
  \Drupal::state()->delete('search_api_solr.site_hash');
}

/**
 * Gets all backend configs for active Solr servers.
 *
 * @param string $pattern
 *
 * @return array
 *   All backend configs for active Solr servers keyed by server name.
 */
function search_api_solr_update_helper_get_backend_configs($pattern = 'solr') {
  $config_factory = \Drupal::configFactory();
  $backend_configs = [];
  foreach ($config_factory->listAll('search_api.server.') as $server_name) {
    $server = $config_factory->get($server_name);
    // Covers search_api_solr_multilingual, too.
    if (strpos($server->get('backend'), $pattern) !== FALSE) {
      $backend_configs[$server_name] = $server->get('backend_config');
    }
  }
  return $backend_configs;
}

/**
 * Saves a modified backend config for a given Solr server.
 *
 * @param string $server_name
 * @param array $backend_config
 * @param bool $trusted_data
 */
function search_api_solr_update_helper_save_backend_config($server_name, array $backend_config, $trusted_data = TRUE) {
  \Drupal::configFactory()->getEditable($server_name)
    ->set('backend_config', $backend_config)
    ->save($trusted_data);
}

/**
 * Gets all index third party settings for Solr servers.
 *
 * @param string $pattern
 *
 * @return array
 *   All backend configs for active Solr servers keyed by server name.
 */
function search_api_solr_update_helper_get_index_third_party_settings($pattern = 'solr') {
  $backend_configs = search_api_solr_update_helper_get_backend_configs($pattern);
  $indexes = search_api_solr_update_helper_get_indexes($pattern);
  $index_third_party_settings = [];
  foreach ($indexes as $index_id => $index) {
    if (isset($backend_configs['search_api.server.' . $index->get('server')])) {
      // This index belongs to a Solr server.
      $index_third_party_settings[$index_id] = $index->get('third_party_settings.search_api_solr');
    }
  }
  return $index_third_party_settings;
}

/**
 * Saves a modified backend config for a given Solr server.
 *
 * @param string $index_id
 * @param array $third_party_settings
 * @param bool $trusted_data
 */
function search_api_solr_update_helper_save_index_third_party_settings($index_id, array $third_party_settings, $trusted_data = TRUE) {
  \Drupal::configFactory()->getEditable($index_id)
    ->set('third_party_settings.search_api_solr', $third_party_settings)
    ->save($trusted_data);
}

/**
 * Gets all index settings for Solr servers.
 *
 * @param string $pattern
 *
 * @return array
 *   All index configs for Solr servers keyed by index name.
 */
function search_api_solr_update_helper_get_indexes($pattern = 'solr') {
  $backend_configs = search_api_solr_update_helper_get_backend_configs($pattern);
  $config_factory = \Drupal::configFactory();
  $indexes = [];
  foreach ($config_factory->listAll('search_api.index.') as $index_id) {
    $index = $config_factory->get($index_id);
    if (isset($backend_configs['search_api.server.' . $index->get('server')])) {
      // This index belongs to a Solr server.
      $indexes[$index_id] = $index;
    }
  }
  return $indexes;
}

/**
 * Saves a modified index config.
 *
 * @param string $index_id
 * @param array $third_party_settings
 * @param bool $trusted_data
 */
function search_api_solr_update_helper_save_indexes($index_id, array $settings, $trusted_data = TRUE) {
  \Drupal::configFactory()->getEditable($index_id)
    ->setData($settings)
    ->save($trusted_data);
}

/**
 * Gets all solr field type configs.
 *
 * @return array
 *   All solr field type configs.
 */
function search_api_solr_update_helper_get_field_type_configs() {
  $config_factory = \Drupal::configFactory();
  $field_type_configs = [];
  foreach ($config_factory->listAll('search_api_solr.solr_field_type.') as $field_type_name) {
    $field_type_configs[$field_type_name] = $config_factory->get($field_type_name)->getRawData();
  }
  return $field_type_configs;
}

/**
 * Saves a modified solr field type config.
 *
 * @param string $field_type_name
 * @param array $field_type_config
 * @param bool $trusted_data
 */
function search_api_solr_update_helper_save_field_type_config($field_type_name, array $field_type_config, $trusted_data = TRUE) {
  \Drupal::configFactory()->getEditable($field_type_name)
    ->setData($field_type_config)
    ->save($trusted_data);
}

/**
 * Helper function to install all new configs.
 *
 * @param string $directory
 */
function search_api_solr_update_helper_install_configs($directory = InstallStorage::CONFIG_OPTIONAL_DIRECTORY) {
  /** @var \Drupal\Core\Config\ConfigInstallerInterface $config_installer */
  $config_installer = \Drupal::service('config.installer');
  $config_installer->installDefaultConfig('module', 'search_api_solr');

  $optional_install_path = \Drupal::moduleHandler()->getModule('search_api_solr')->getPath() . '/' . $directory;
  if (is_dir($optional_install_path)) {
    // Install any optional config the module provides.
    $storage = new FileStorage($optional_install_path, StorageInterface::DEFAULT_COLLECTION);
    $config_installer->installOptionalConfig($storage);
  }

  $restrict_by_dependency = [
    'module' => 'search_api_solr',
  ];
  $config_installer->installOptionalConfig(NULL, $restrict_by_dependency);
}

/**
 * Split Solr paths stored in configurations into server and core parts.
 */
function search_api_solr_update_8001() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $parts = explode('/', $backend_config['path']);
    if (count($parts) > 2) {
      $backend_config['core'] = array_pop($parts);
      $backend_config['path'] = implode('/', $parts);
      search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
    }
  }
}

/**
 * Convert http_user and http_pass to username and password config for Solarium.
 */
function search_api_solr_update_8002() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['username'] = $backend_config['http_user'];
    $backend_config['password'] = $backend_config['http_pass'];
    unset($backend_config['http_user'], $backend_config['http_pass']);
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Add default timeout settings to existing configs.
 */
function search_api_solr_update_8003() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['timeout'] = 5;
    $backend_config['index_timeout'] = 5;
    $backend_config['optimize_timeout'] = 10;
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Migrate existing backend configurations to the basic auth connector plugin.
 */
function search_api_solr_update_8004() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['connector'] = 'basic_auth';
    $backend_config['connector_config'] = [];
    foreach (['scheme', 'host', 'port', 'path', 'core', 'timeout', 'index_timeout', 'optimize_timeout', 'solr_version', 'http_method', 'username', 'password'] as $key) {
      $backend_config['connector_config'][$key] = $backend_config[$key];
      unset($backend_config[$key]);
    }
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Add commit_within settings to existing connector configs.
 */
function search_api_solr_update_8005() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['connector_config']['commit_within'] = 1000;
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Add autocomplete settings to existing configs.
 */
function search_api_solr_update_8006() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['suggest_suffix'] = TRUE;
    $backend_config['suggest_corrections'] = TRUE;
    $backend_config['suggest_words'] = FALSE;
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Remove old autocomplete settings in existing configs.
 */
function search_api_solr_update_8007() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    unset($backend_config['autocorrect_spell']);
    unset($backend_config['autocorrect_suggest_words']);
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Remove obsolete settings in existing configs.
 */
function search_api_solr_update_8008() {
  $config_factory = \Drupal::configFactory();
  foreach ($config_factory->listAll('search_api_solr.settings.') as $setting) {
    $config = $config_factory->getEditable($setting);
    $data = $config->getRawData();
    unset($data['autocomplete_max_occurrences']);
    unset($data['http_get_max_length']);
    $config->setData($data);
    $config->save(TRUE);
  }
}

/**
 * Remove Search API Multilingual Solr Search left-overs.
 */
function search_api_solr_update_8200() {
  $database = Drupal::database();

  $database->delete('key_value')
    ->condition('collection', 'system.schema')
    ->condition('name', 'search_api_solr_multilingual')
    ->execute();
}

/**
 * Fix suggester field type.
 */
function search_api_solr_update_8201() {
  foreach (search_api_solr_update_helper_get_field_type_configs() as $field_type_name => $field_type_config) {
    if (!empty($field_type_config['solr_configs']) && !empty($field_type_config['solr_configs']['searchComponents'])) {
      foreach ($field_type_config['solr_configs']['searchComponents'] as &$component) {
        if ($component['name'] == 'suggest') {
          foreach ($component['lst'] as &$lst) {
            foreach ($lst['str'] as &$str) {
              foreach ($lst['str'] as &$entry) {
                if ($entry['name'] == 'field') {
                  $entry['VALUE'] = 'twm_suggest';
                  search_api_solr_update_helper_save_field_type_config($field_type_name, $field_type_config);
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
}

/**
 * Enable support for targeted domains for all backends and add custom codes.
 */
function search_api_solr_update_8202() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    if (!isset($backend_config['domain'])) {
      if (isset($backend_config['sasm_domain'])) {
        $backend_config['domain'] = $backend_config['sasm_domain'];
        unset($backend_config['sasm_domain']);
      }
      else {
        $backend_config['domain'] = 'generic';
      }
    }
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }

  foreach (search_api_solr_update_helper_get_field_type_configs() as $field_type_name => $field_type_config) {
    if (!isset($field_type_config['custom_code'])) {
      $field_type_config['custom_code'] = '';
    }
    search_api_solr_update_helper_save_field_type_config($field_type_name, $field_type_config);
  }
}

/**
 * Install new essential Solr field types.
 */
function search_api_solr_update_8203() {
  // Removed.
}

/**
 * Enable phrase suggestions support.
 */
function search_api_solr_update_8204() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    if (!isset($backend_config['suggest_phrases'])) {
      $backend_config['suggest_phrases'] = FALSE;
    }
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Drop never implemented word suggestions support.
 */
function search_api_solr_update_8205() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    if (isset($backend_config['suggest_words'])) {
      unset($backend_config['suggest_words']);
    }
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Remove obsolete autocomplete settings.
 */
function search_api_solr_update_8206() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    unset($backend_config['suggest_suffix']);
    unset($backend_config['suggest_corrections']);
    unset($backend_config['suggest_phrases']);
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }
}

/**
 * Fix language undefined field types.
 */
function search_api_solr_update_8207() {
  foreach (search_api_solr_update_helper_get_field_type_configs() as $field_type_name => $field_type_config) {
    if (strpos($field_type_name, 'text_und') === 0) {
      if (!empty($field_type_config['field_type']) && !empty($field_type_config['field_type']['analyzers'])) {
        foreach ($field_type_config['field_type']['analyzers'] as &$component) {
          foreach ($component['filters'] as &$filter) {
            foreach ($filter as &$entry) {
              if ($entry['class'] == 'solr.SnowballPorterFilterFactory') {
                unset($entry);
              }
            }
          }
        }
      }
      search_api_solr_update_helper_save_field_type_config($field_type_name, $field_type_config);
    }
  }
}

/**
 * Enable new highlighter.
 */
function search_api_solr_update_8208() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    if (isset($backend_config['excerpt'])) {
      unset($backend_config['excerpt']);
    }
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }

  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('search_api_solr.standard_highlighter');
  $data = $config->getRawData();
  unset($data['excerpt']);
  $data['highlight']['snippets'] = 3;
  $data['highlight']['fragsize'] = 0;
  $config->setData($data);
  $config->save(TRUE);
}

/**
 * Install missing configs for 8.x-2.0-alpha3.
 */
function search_api_solr_update_8209() {
  // search_api_solr_update_helper_install_configs(InstallStorage::CONFIG_INSTALL_DIRECTORY);
}

/**
 * Install missing configs for 8.x-2.0-beta1.
 */
function search_api_solr_update_8210() {
  // search_api_solr_update_helper_install_configs(InstallStorage::CONFIG_OPTIONAL_DIRECTORY);
}

/**
 * Add default finalize timeout settings to existing configs.
 */
function search_api_solr_update_8211() {
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    if (!isset($backend_config['finalize_timeout'])) {
      $backend_config['finalize_timeout'] = 30;
      search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
    }
  }
}

/**
 * Configure highlighter individually per index and remove global config.
 */
function search_api_solr_update_8212() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('search_api_solr.standard_highlighter');
  $data = $config->getRawData();

  foreach (search_api_solr_update_helper_get_index_third_party_settings() as $index_id => $third_party_settings) {
    if (!isset($third_party_settings['highlighter'])) {
      $third_party_settings['highlighter'] = $data;
    }
    search_api_solr_update_helper_save_index_third_party_settings($index_id, $third_party_settings);
  }

  $config->delete();
}

/**
 * Configure index prefixes individually per server and index.
 */
function search_api_solr_update_8213() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('search_api_solr.settings');
  $data = $config->getRawData();

  foreach (search_api_solr_update_helper_get_index_third_party_settings() as $index_id => $third_party_settings) {
    if (!isset($third_party_settings['advanced']) || !isset($third_party_settings['advanced']['index_prefix'])) {
      $third_party_settings['advanced']['index_prefix'] = isset($data['index_prefix_' . $index_id]) ? $data['index_prefix_' . $index_id] : '';
      unset($data['index_prefix_' . $index_id]);
    }
    search_api_solr_update_helper_save_index_third_party_settings($index_id, $third_party_settings);
  }

  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    if (!isset($backend_config['server_prefix'])) {
      $backend_config['server_prefix'] = isset($data['index_prefix']) ? $data['index_prefix'] : '';
      search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
    }
  }
  unset($data['index_prefix']);

  $config->setData($data);
  $config->save(TRUE);
}

/**
 * Migrate Solr backends to the new unified Solr backend.
 */
function search_api_solr_update_8300() {
  $config_factory = \Drupal::configFactory();
  foreach ($config_factory->listAll('search_api_solr.solr_field_type.m_') as $field_type_name) {
    $config_factory->getEditable($field_type_name)->delete();
  }

  foreach (search_api_solr_update_helper_get_field_type_configs() as $field_type_name => $field_type_config) {
    unset($field_type_config['managed_schema']);
    search_api_solr_update_helper_save_field_type_config($field_type_name, $field_type_config);
  }

  foreach ($config_factory->listAll('search_api.server.') as $server_name) {
    $server = $config_factory->getEditable($server_name);
    $backend_config = $server->get('backend_config');
    switch ($server->get('backend')) {
      case 'search_api_solr':
        $backend_config['sasm_limit_search_page_to_content_language'] = FALSE;
        $backend_config['sasm_search_page_include_language_independent'] = TRUE;
        break;

      case 'search_api_solr_multilingual':
      case 'search_api_solr_multilingual_managed_schema':
        unset($backend_config['sasm_language_unspecific_fallback_on_schema_issues']);
        $server->set('backend', 'search_api_solr');
        break;

      case 'search_api_solr_any_schema':
        $backend_config['sasm_limit_search_page_to_content_language'] = FALSE;
        $backend_config['sasm_search_page_include_language_independent'] = TRUE;
        $server->set('backend', 'search_api_solr');
        break;

      default:
        continue(2);
    }
    $server->set('backend_config', $backend_config)
      ->save(TRUE);
  }

  foreach ($config_factory->listAll('search_api.index.') as $index_name) {
    $index = $config_factory->getEditable($index_name);
    $field_settings = $index->get('field_settings');
    foreach ($field_settings as &$field_setting) {
      if ('solr_string_doc_values' == $field_setting['type']) {
        $field_setting['type'] = 'string';
      }
    }

    $index->set('field_settings', $field_settings)
      ->save(TRUE);
  }
}

/**
 * Field types clean-up.
 */
function search_api_solr_update_8301() {
  search_api_solr_update_helper_install_configs();

  $config_factory = \Drupal::configFactory();
  foreach ($config_factory->listAll('search_api.index.') as $index_name) {
    $index = $config_factory->getEditable($index_name);
    $field_settings = $index->get('field_settings');
    foreach ($field_settings as &$field_setting) {
      if ('solr_text_ngram' == $field_setting['type']) {
        $field_setting['type'] = 'solr_text_custom:edge';
      }
      if ('solr_string_ngram' == $field_setting['type']) {
        $field_setting['type'] = 'solr_text_custom:edgestring';
      }
      if ('solr_text_phonetic' == $field_setting['type']) {
        $field_setting['type'] = 'solr_text_custom:phonetic';
      }
    }

    $index->set('field_settings', $field_settings)
      ->save(TRUE);
  }
}

/**
 * Re-install language-specific field types to enable the new spellcheckers.
 */
function search_api_solr_update_8302() {
  $config_factory = \Drupal::configFactory();
  foreach ($config_factory->listAll('search_api_solr.solr_field_type.text_') as $field_type_name) {
    if (preg_match('/^search_api_solr\.solr_field_type\.text_[a-z]{2}[_-]{1}/', $field_type_name)) {
      $config_factory->getEditable($field_type_name)->delete();
    }
  }

  search_api_solr_update_helper_install_configs();
}

/**
 * Remove obsolete setting in config.
 */
function search_api_solr_update_8303() {
  // obsolete because of search_api_solr_update_8304().
}

/**
 * Convert site_hash from setting to state.
 */
function search_api_solr_update_8304() {
  $config_factory = \Drupal::configFactory();
  $settings = $config_factory->getEditable('search_api_solr.settings');
  \Drupal::state()->set('search_api_solr.site_hash', $settings->get('site_hash', ''));
  $settings->delete();

  foreach ($config_factory->listAll('search_api.server.') as $server_name) {
    $server = $config_factory->getEditable($server_name);
    $backend_config = $server->get('backend_config');
    $backend_config['optimize'] = FALSE;
    $server->set('backend_config', $backend_config)->save(TRUE);
  }
}

/**
 * Add Dutch nouns and improve stemming for Dutch language.
 */
function search_api_solr_update_8305() {
  $nouns = '';

  foreach (search_api_solr_update_helper_get_field_type_configs() as $field_type_name => $field_type_config) {
    if (strpos($field_type_name, 'text_nl') !== FALSE) {
      if (!empty($field_type_config['field_type']) && !empty($field_type_config['field_type']['analyzers'])) {
        foreach ($field_type_config['field_type']['analyzers'] as &$component) {
          foreach ($component['filters'] as &$filter) {
            if ($filter['class'] == 'solr.SnowballPorterFilterFactory') {
              if ($filter['language'] == 'Dutch') {
                $filter['language'] = 'Kp';
              }
            }
          }
        }
      }
      if (!empty($field_type_config['text_files'])) {
        if (empty($field_type_config['text_files']['nouns']) || $field_type_config['text_files']['nouns'] == PHP_EOL) {
          if (!$nouns) {
            // We always use this hardcoded source file to have valid one for
            // different domains created by users, example:
            // text_nl_scientific_6_0_0.
            $filename = __DIR__ . '/config/optional/search_api_solr.solr_field_type.text_nl_7_0_0.yml';
            $nouns = Yaml::decode(file_get_contents($filename));
          }
          $field_type_config['text_files']['nouns'] = $nouns['text_files']['nouns'];
        }
      }
      search_api_solr_update_helper_save_field_type_config($field_type_name, $field_type_config);
    }
  }
}

/**
 * Replace deprecated Solr filters by their successors for Solr 7.
 */
function search_api_solr_update_8306() {
  foreach (search_api_solr_update_helper_get_field_type_configs() as $field_type_name => $field_type_config) {
    if (
      version_compare($field_type_config['minimum_solr_version'], '7.0.0', '>=') &&
      !empty($field_type_config['field_type']) &&
      !empty($field_type_config['field_type']['analyzers'])
    ) {
      foreach ($field_type_config['field_type']['analyzers'] as &$component) {
        foreach ($component['filters'] as &$filter) {
          switch ($filter['class']) {
            case 'solr.WordDelimiterFilterFactory':
              $filter['class'] = 'solr.WordDelimiterGraphFilterFactory';
              break;
            case 'solr.SynonymFilterFactory':
              $filter['class'] = 'solr.SynonymGraphFilterFactory';
              break;
            case 'solr.StopFilterFactory':
              unset($filter['enablePositionIncrements']);
              break;
          }
        }
      }
    }
    search_api_solr_update_helper_save_field_type_config($field_type_name, $field_type_config);
  }
}

/**
 * Avoid redundant text files in generated Solr config files.
 */
function search_api_solr_update_8307() {
  $edge_7 = $ngram_7 = FALSE;
  foreach (search_api_solr_update_helper_get_field_type_configs() as $field_type_name => $field_type_config) {
    if (
      strpos($field_type_name, 'text_phonetic') !== FALSE ||
      strpos($field_type_name, 'text_edge_und') !== FALSE ||
      strpos($field_type_name, 'text_ngram_und') !== FALSE
    ) {
      $dependency = str_replace(['text_phonetic', 'text_edge_und', 'text_ngram_und'], ['text', 'text_und', 'text_und'], $field_type_name);
      if (!isset($field_type_config['dependencies']['config']) || !in_array($dependency, $field_type_config['dependencies']['config'])) {
        $field_type_config['dependencies']['config'][] = $dependency;
      }
      if (!empty($field_type_config['field_type']) && !empty($field_type_config['field_type']['analyzers'])) {
        foreach ($field_type_config['field_type']['analyzers'] as &$component) {
          if (!empty($component['charFilters'])) {
            foreach ($component['charFilters'] as &$charFilter) {
              if ($charFilter['class'] == 'solr.MappingCharFilterFactory') {
                $charFilter['mapping'] = 'accents_' . $field_type_config['field_type_language_code'] . '.txt';
              }
            }
          }
          foreach ($component['filters'] as &$filter) {
            if (
              $filter['class'] == 'solr.WordDelimiterFilterFactory' ||
              $filter['class'] == 'solr.WordDelimiterGraphFilterFactory'
            ) {
              $filter['protected'] = 'protwords_' . $field_type_config['field_type_language_code'] . '.txt';
            }
            elseif ($filter['class'] == 'solr.DictionaryCompoundWordTokenFilterFactory') {
              $filter['dictionary'] = 'nouns_' . $field_type_config['field_type_language_code'] . '.txt';
            }
            elseif ($filter['class'] == 'solr.StopFilterFactory') {
              $filter['words'] = 'stopwords_' . $field_type_config['field_type_language_code'] . '.txt';
            }
            elseif (
              $filter['class'] == 'solr.SynonymFilterFactory' ||
              $filter['class'] == 'solr.SynonymGraphFilterFactory'
            ) {
              $filter['synonyms'] = 'synonyms_' . $field_type_config['field_type_language_code'] . '.txt';
            }
          }
        }
      }
      if (!empty($field_type_config['text_files'])) {
        $field_type_config['text_files'] = [];
      }
      search_api_solr_update_helper_save_field_type_config($field_type_name, $field_type_config);
      if (strpos($field_type_name, 'text_edge_und_7') !== FALSE) {
        $edge_7 = TRUE;
      }
      elseif (strpos($field_type_name, 'text_ngram_und_7') !== FALSE) {
        $ngram_7 = TRUE;
      }
    }
  }
  if (!$edge_7) {
    $filename = __DIR__ . '/config/install/search_api_solr.solr_field_type.text_edge_und_7_0_0.yml';
    $config = SolrFieldType::create(Yaml::decode(file_get_contents($filename)));
    $config->save();
  }
  if (!$ngram_7) {
    $filename = __DIR__ . '/config/install/search_api_solr.solr_field_type.text_ngram_und_7_0_0.yml';
    $config = SolrFieldType::create(Yaml::decode(file_get_contents($filename)));
    $config->save();
  }
}

/**
 * Configure multilingual features individually per index.
 */
function search_api_solr_update_8308() {
  $settings = [];
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    \Drupal::state()->delete('sasm.' . $server_name . '.schema_parts');
    $settings[$server_name] = [
      'limit_to_content_language' => FALSE,
      'include_language_independent' => TRUE,
    ];
    if (isset($backend_config['sasm_limit_search_page_to_content_language'])) {
      $settings[$server_name]['limit_to_content_language'] = $backend_config['sasm_limit_search_page_to_content_language'];
      unset($backend_config['sasm_limit_search_page_to_content_language']);
    }
    if (isset($backend_config['sasm_search_page_include_language_independent'])) {
      $settings[$server_name]['include_language_independent'] = $backend_config['sasm_search_page_include_language_independent'];
      unset($backend_config['sasm_search_page_include_language_independent']);
    }
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }

  $indexes = search_api_solr_update_helper_get_indexes();
  foreach (search_api_solr_update_helper_get_index_third_party_settings() as $index_id => $third_party_settings) {
    if (!isset($third_party_settings['multilingual']) || !isset($third_party_settings['multilingual']['limit_to_content_language'])) {
      $third_party_settings['multilingual']['limit_to_content_language'] = $settings['search_api.server.' . $indexes[$index_id]->get('server')]['limit_to_content_language'];
    }
    if (!isset($third_party_settings['multilingual']) || !isset($third_party_settings['multilingual']['include_language_independent'])) {
      $third_party_settings['multilingual']['include_language_independent'] = $settings['search_api.server.' . $indexes[$index_id]->get('server')]['include_language_independent'];
    }
    search_api_solr_update_helper_save_index_third_party_settings($index_id, $third_party_settings);
  }
}

/**
 * Use solarium 4.3.
 */
function search_api_solr_update_8309() {
  // Remove the V1 API endpoint from the path.
  foreach (search_api_solr_update_helper_get_backend_configs() as $server_name => $backend_config) {
    $backend_config['connector_config']['path'] = preg_replace('@/solr$@', '/', $backend_config['connector_config']['path']);
    search_api_solr_update_helper_save_backend_config($server_name, $backend_config);
  }

  // Reset the states.
  \Drupal::state()->delete('search_api_solr.endpoint.data');
}

/**
 * Enable language-specific collations
 */
function search_api_solr_update_8310()
{
  $valid_icu_locales = [
    'ar', 'cs', 'da', 'de', 'el', 'en', 'es', 'fi', 'fr', 'it', 'ja', 'nl',
    'pl', 'ru', 'sk', 'uk', 'br', 'be', 'zh', 'tr', 'th', 'sl', 'ro', 'pt',
    'mk', 'is', 'hr', 'bg', 'af', 'yi', 'vi', 'sv', 'sr', 'sq', 'si', 'pa',
    'or', 'nn', 'ne', 'my', 'mt', 'lt', 'ln', 'ko', 'id', 'hu', 'hi', 'he',
    'fa', 'et', 'am',
    ];

  foreach (search_api_solr_update_helper_get_field_type_configs() as $field_type_name => $field_type_config) {
    if (empty($field_type_config['collated_field_type'])) {
      if (
        !in_array($field_type_config['field_type_language_code'], $valid_icu_locales) ||
        empty($field_type_config['spellcheck_field_type'])
      ) {
        continue;
      }

      $field_type_config['collated_field_type'] = [
        'name' => 'collated_' . $field_type_config['field_type_language_code'],
        'class' => 'solr.ICUCollationField',
        'locale' => $field_type_config['field_type_language_code'],
        'strength' => 'primary',
        'caseLevel' => FALSE,
      ];
    }

    search_api_solr_update_helper_save_field_type_config($field_type_name, $field_type_config);
  }
}
