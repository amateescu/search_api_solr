<?php

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\search_api\Entity\Server;
use Drupal\search_api\SearchApiException;
use Drupal\search_api\ServerInterface;
use Drupal\search_api_solr\SolrBackendInterface;

/**
 * Implements hook_help().
 */
function search_api_solr_help($route_name, RouteMatchInterface $route_match) {
  if ($route_name == 'search_api.overview') {
    // Included because we need the REQUIREMENT_* constants.
    include_once DRUPAL_ROOT . '/core/includes/install.inc';
    module_load_include('install', 'search_api_solr');
    $reqs = search_api_solr_requirements('runtime');
    foreach ($reqs as $req) {
      if (isset($req['description'])) {
        $type = $req['severity'] == REQUIREMENT_ERROR ? 'error' : ($req['severity'] == REQUIREMENT_WARNING ? 'warning' : 'status');
        drupal_set_message($req['description'], $type);
      }
    }
  }
}

/**
 * Implements hook_cron().
 *
 * Used to execute an optimization operation on all enabled Solr servers once a
 * day.
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\search_api\SearchApiException
 */
function search_api_solr_cron() {
  $action = \Drupal::config('search_api_solr.settings')->get('cron_action');
  // We treat all unknown action settings as "none". However, we turn a blind
  // eye for Britons and other people who can spell.
  if (!in_array($action, ['spellcheck', 'optimize', 'optimise'])) {
    return;
  }
  // 86400 seconds is one day. We use slightly less here to allow for some
  // variation in the request time of the cron run, so that the time of day will
  // (more or less) stay the same.
  if (REQUEST_TIME - \Drupal::state()->get('search_api_solr.last_optimize') > 86340) {
    \Drupal::state()->set('search_api_solr.last_optimize', REQUEST_TIME);

    $count = 0;
    foreach (search_api_solr_get_servers() as $server) {
      try {
        /** @var \Drupal\search_api_solr\SolrBackendInterface $backend */
        $backend = $server->getBackend();
        $connector = $backend->getSolrConnector();
        if ($action != 'spellcheck') {
          $connector->optimize();
        }
        else {
          $autocomplete_query = $connector->getAutocompleteQuery();

          $spellcheck_component = $autocomplete_query->getSpellcheck();
          $spellcheck_component->setBuild(TRUE);

          // Terms don't need to be build. Suggesters are configured to be
          // buildOnCommit.
          $connector->execute($autocomplete_query);
        }
        ++$count;
      }
      catch (SearchApiException $e) {
        watchdog_exception('search_api_solr', $e, '%type while optimizing Solr server @server: @message in %function (line %line of %file).', ['@server' => $server->label()]);
      }
    }
    if ($count) {
      $vars['@count'] = $count;
      if ($action != 'spellcheck') {
        \Drupal::logger('search_api_solr')->info('Optimized @count Solr server(s).', $vars);
      }
      else {
        \Drupal::logger('search_api_solr')->info('Rebuilt spellcheck dictionary on @count Solr server(s).', $vars);
      }
    }

    // Delete cached endpoint data once a day.
    \Drupal::state()->delete('search_api_solr.endpoint.data');
  }
}

/**
 *
 */
function search_api_solr_form_search_api_index_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // We need to restrict by form ID here because this function is also called
  // via hook_form_BASE_FORM_ID_alter (which is wrong, e.g. in the case of the
  // form ID search_api_field_config).
  if (in_array($form_id, ['search_api_index_form', 'search_api_index_edit_form']) &&
      isset($form['server'])) {
    $form['server']['#element_validate'][] = 'search_api_solr_form_search_api_index_form_validate_server';
  }
}

/**
 *
 */
function search_api_solr_form_search_api_index_form_validate_server(&$element, FormStateInterface $form_state, $form) {
  if ($server = Server::load($form_state->getValue('server'))) {
    if ($server->getBackend() instanceof SolrBackendInterface) {
      /** @var \Drupal\Core\Entity\EntityFormInterface $form_object */
      $form_object = $form_state->getFormObject();
      $this_index = $form_object->getEntity();
      $indexes = $server->getIndexes();
      $index_count = 0;
      foreach ($indexes as $index) {
        if ($index->status()) {
          if (!$this_index->isNew() && ($this_index->id() == $index->id())) {
            continue;
          }
          ++$index_count;
        }
      }
      if ($index_count > 0 && $form_state->getValue('status')) {
        $msg = t('The concept of storing multiple "virtual" Search API indexes in one Solr index (aka core) is bad practice and randomly breaks a lot of advanced features like spell checking, suggestions, automplete and others. Create a second core within your Solr server and assign this "index" to that core.');
        if ($this_index->isNew()) {
          // Avoid creating multiple indexes on one server.
          $form_state->setError($element, $msg);
        }
        else {
          // Allow editing existing multiple indexes on one server for backward
          // compatibility.
          drupal_set_message($msg, 'error');
        }
      }
    }
  }
}

/**
 * Implements hook_search_api_views_handler_mapping_alter()
 *
 * @param array $mapping
 *   An associative array with data types as the keys and Views field data
 *   definitions as the values. In addition to all normally defined data types,
 *   keys can also be "options" for any field with an options list, "entity" for
 *   general entity-typed fields or "entity:ENTITY_TYPE" (with "ENTITY_TYPE"
 *   being the machine name of an entity type) for entities of that type.
 *
 * @see _search_api_views_handler_mapping()
 */
function search_api_solr_search_api_views_handler_mapping_alter(&$mapping) {
  $mapping['solr_text_ngram'] =
  $mapping['solr_text_omit_norms'] =
  $mapping['solr_text_phonetic'] =
  $mapping['solr_text_unstemmed'] =
  $mapping['solr_text_wstoken'] = [
    'argument' => [
      'id' => 'search_api',
    ],
    'filter' => [
      'id' => 'search_api_fulltext',
    ],
    'sort' => [
      'id' => 'search_api',
    ],
  ];

  $mapping['solr_string_ngram'] = [
    'argument' => [
      'id' => 'search_api',
    ],
    'filter' => [
      'id' => 'search_api_string',
    ],
    'sort' => [
      'id' => 'search_api',
    ],
  ];
}

/**
 * Implements hook_views_data_alter().
 *
 * Remove fields from solr_document datasources from the views data. Datasource
 * fields that have been added to the index would be duplicated in the Views Add
 * fields list. Fields that aren't added to the index can't be displayed.
 */
function search_api_solr_views_data_alter(array &$data) {
  // @todo check for a search_api based view first.
  foreach ($data as $key => $fields) {
    if (preg_match('/search_api_datasource_(.+)_solr_document/', $key)) {
      unset($data[$key]);
    }
  }
}

/**
 * Deletes all Solr Field Type and re-installs them from their yml files.
 */
function search_api_solr_delete_and_reinstall_all_field_types() {
  $storage = \Drupal::entityTypeManager()->getStorage('solr_field_type');
  $storage->delete($storage->loadMultiple());

  /** @var \Drupal\Core\Config\ConfigInstallerInterface $config_installer */
  $config_installer = \Drupal::service('config.installer');
  $config_installer->installDefaultConfig('module', 'search_api_solr');
  $restrict_by_dependency = [
    'module' => 'search_api_solr',
  ];
  $config_installer->installOptionalConfig(NULL, $restrict_by_dependency);
}

/**
 * Get all Search API servers that use a Solr backend.
 *
 * @param bool $only_active
 *
 * @return ServerInterface[]
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\search_api\SearchApiException
 */
function search_api_solr_get_servers($only_active = TRUE) {
  $solr_servers = [];
  $storage = \Drupal::entityTypeManager()->getStorage('search_api_server');
  /** @var ServerInterface[] $servers */
  $servers = $only_active ? $storage->loadByProperties(['status' => TRUE]) :
    $storage->loadMultiple();
  foreach ($servers as $server) {
    if (
      $server->hasValidBackend() &&
      $server->getBackend() instanceof SolrBackendInterface
    ) {
      $solr_servers[] = $server;
    }
  }
  return $solr_servers;
}
